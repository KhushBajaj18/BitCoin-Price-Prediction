# -*- coding: utf-8 -*-
"""important.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10MKeHeIV0Hohp0WyQ8M7s8wq-tVujqQM
"""

import pandas as pd
import numpy as np
import pickle
import matplotlib.pyplot as plt
from sklearn.neural_network import MLPRegressor
from sklearn.metrics import mean_squared_error
from prophet import Prophet
from statsmodels.tsa.arima.model import ARIMA

# Load your historical Bitcoin price dataset into a DataFrame
# Replace "your_dataset.csv" with the actual filename or path
bitcoin_df = pd.read_csv("BTC-2018min.csv")

def plot_historical_prices(df):
    """
    Plots the historical Bitcoin price data.

    Args:
      df: A Pandas DataFrame containing the historical Bitcoin price data.
    """

    plt.figure(figsize=(12, 6))
    plt.plot(df["date"], df["close"], label="Bitcoin Price (USD)")
    plt.xlabel("Date")
    plt.ylabel("Price (USD)")
    plt.title("Historical Bitcoin Price Data")
    plt.legend()
    plt.show()

def check_data_quality(df):
    """
    Checks the historical Bitcoin price data for any quality issues.

    Args:
      df: A Pandas DataFrame containing the historical Bitcoin price data.

    Returns:
      A list of any data quality issues found.
    """

    issues = []

    # Check for missing values.
    if df.isnull().values.any():
        issues.append("Missing values found.")

    # Check for duplicate values.
    if df.duplicated().values.any():
        issues.append("Duplicate values found.")

    # Check for invalid data types.
    for col in df.columns:
        if not pd.api.types.is_numeric_dtype(df[col]):
            issues.append(f"Invalid data type found in {col} column.")

    return issues

def choose_model(df):
    """
    Chooses a Machine Learning algorithm for time-series forecasting.

    Args:
      df: A Pandas DataFrame containing the historical Bitcoin price data.

    Returns:
      A Scikit-learn model.
    """

    # Split the data into training and testing sets.
    train_data = df.iloc[:-30]
    test_data = df.iloc[-30:]

    # Evaluate different models.
    models = [
        ("LSTM", MLPRegressor(hidden_layer_sizes=(100, 100, 100), activation="tanh")),
        ("ARIMA", ARIMA(train_data["close"], order=(2, 1, 1))),
        ("Prophet", Prophet())
    ]

    models_to_rmse = {}
    for name, model in models:
        try:
            model.fit(train_data["close"].values.reshape(-1, 1))
            predictions = model.predict(test_data["close"].values.reshape(-1, 1))
            rmse = np.sqrt(mean_squared_error(test_data["close"], predictions))
            models_to_rmse[name] = rmse
        except Exception as e:
            print(f"Error training {name} model:", e)

    # Choose the model with the best performance.
    best_model = min(models_to_rmse, key=models_to_rmse.get)

    return best_model

def train_model(model, train_data, save_path="model.pkl"):
    """
    Trains the Machine Learning model on the historical Bitcoin price data.

    Args:
      model: A Scikit-learn model.
      train_data: A Pandas DataFrame containing the historical Bitcoin price data.
      save_path: The path to a file where the trained model should be saved.
    """

    try:
        model.fit(train_data["close"].values.reshape(-1, 1))

        if save_path is not None:
            with open(save_path, "wb") as f:
                pickle.dump(model, f)

    except Exception as e:
        print("Error training the model:", e)

# Main code
bitcoin_df["date"] = pd.to_datetime(bitcoin_df["date"])
plot_historical_prices(bitcoin_df)
data_quality_issues = check_data_quality(bitcoin_df)
if data_quality_issues:
    print("Data quality issues found:", data_quality_issues)
else:
    best_model = choose_model(bitcoin_df)
    print("Best model selected:", best_model)
    train_model(best_model, bitcoin_df)
